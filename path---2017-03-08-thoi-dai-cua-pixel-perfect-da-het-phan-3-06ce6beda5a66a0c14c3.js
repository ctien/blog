webpackJsonp([90],{"./node_modules/json-loader/index.js!./.cache/json/2017-03-08-thoi-dai-cua-pixel-perfect-da-het-phan-3.json":function(n,t){n.exports={data:{markdownRemark:{html:'<!-- MarkdownTOC -->\n<ul>\n<li>UI kits</li>\n<li>Xuất file</li>\n<li>Element state</li>\n<li>Line-Height</li>\n<li>Font</li>\n<li>Kết</li>\n</ul>\n<!-- /MarkdownTOC -->\n<h1>UI kits</h1>\n<p>UI kit là tất cả những elment bạn đang sử dụng trong project, nếu là dân React có thể gọi là component. Sau này khi muốn maintenance sẽ dễ dàng hơn khi dự án ngày càng phình ra.</p>\n<p>Trong cái UI kit cần xác định những thành phần: bảng màu sử dụng, typography, các component như button, input, slider, hover, active state, cũng như người lập trình luôn tâm niệm nếu lập lại một đoạn code một lần thứ 2 trong đời thì cho nó ngay vào thư viện để tái sử dụng. Thường khi các bạn designer không có làm kiểu này thì trước sau gì cũng xảy ra trường hợp cùng một button mà chổ này khác chổ kia khác một chút, mà các bạn tester và khách hàng khác cái giao diện là đè đầu thằng developer ra chửi, trong khi cái đó nhiều khi bạn designer không cố ý mà vô tình quên mất mình đã format cái button đó ở đâu đó rồi.</p>\n<p>Bạn có thể sử dụng <a target="_blank" href="https://www.invisionapp.com/craft"> Craft</a> để làm thư viện UI</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*72sMv26eNctbPvOLKZt-Mw@2x.png"></p>\n<h1>Xuất file</h1>\n<p>Giúp ảnh developer, hãy sử dụng những công cụ sau</p>\n<ul>\n<li><a href="https://www.invisionapp.com/feature/inspect">Invision Inspect</a></li>\n<li><a href="https://zeplin.io/">Zeplin</a></li>\n<li><a href="https://zeplin.io/">Sympli</a></li>\n<li><a href="https://github.com/utom/sketch-measure">Sketch Measure</a> </li>\n</ul>\n<h1>Element state</h1>\n<p>Các bạn design hay chỉ làm mỗi cái trạng thái default mà quên rằng một element sẽ có rất nhiều state khác như, như active, hover, focus, visited</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*oK0YQWhM2Td5A6rqHWlYTA@2x.png"></p>\n<h1>Line-Height</h1>\n<p>Có thể khẳng định là 100% anh designer sẽ không để ý đến giá trị này, mà cứ đè ra đo độ cao chính xác từng pixel của element, trong khi không hề biết cái line-height sẽ ảnh hưởng đến độ cao này, đâm ra anh quên cộng vào, và khi anh developer set cái padding trong code là 13, 14 thì anh la làng là nó phải 20, trong khi nếu cộng vào cái line-height nữa nó sẽ ra là 20.</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*HnnuoS89S6xCdFwWMG9Q2A@2x.png"></p>\n<p>Một ưu điềm khác khi sử dụng Sketch là lúc làm sẽ thấy ngay sự ảnh hưởng line-height, trong khi photoshop thì sẽ không thấy được</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*Vqrt-1Vy2Ng1SqeNXG2P0g@2x.png"></p>\n<p>Giá trị line-height nên không nên thay đổi nhiều quá trên từng element mà thông nhất xài chung một kiểu</p>\n<h1>Font</h1>\n<p>Trước hết, xác định là: "LUÔN LUÔN sử dụng <a href="https://fonts.google.com/">Google Fonts</a>" nếu muốn xài một font không có sẵn trong máy, bạn developer sẽ không phải đi mò mẫm convert cái font chữ của bạn design chôm ở đâu đó, một công việc vốn quá nhiều rủi ro do vấn đề bản quyền, vấn đề lỗi convert có thể xảy ra, lỗi hiển thị trên các trình duyệt khác nhau.</p>\n<p>Cũng không bao giờ được xài nhiều hơn 2 font ngoài hệ thống, quá nhiều font phải load, làm ảnh hưởng tốc độ load site. Không sử dụng quá nhiều font style italic, bold, light, thin, ragular, một đóng hầm bà lằng, luôn nhớ trong đầu less is more</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*KeLj5M7QYKIKkgIneNbKnQ@2x.png"> </p>\n<h1>Kết</h1>\n<p>Thằng designer thì vốn không ưa thằng developer, chê thằng developer không thấy được sự sáng tạo của nó, còn thằng developer thì luôn chửi thằng designer, nó cứ chế biến mấy cái tào lào khó implement chết mịa luôn. Tất cả những vấn đề trên có thể giải quyết bằng một cách thôi: TRAO ĐỔI. Trao đổi càng sớm, trao đổi khi có vấn đề sẽ tránh cho ra kết quả mà nhìn vào không giám nhận là con của mình. Với tất cả những dự án dù lơn hay nhỏ thì luôn luôn bạn phải cân đối giữa kết quả mong muốn, thời gian và chi phí phải bỏ ra</p>',frontmatter:{date:"March 08, 2017",path:"/2017-03-08-thoi-dai-cua-pixel-perfect-da-het-phan-3",tags:["css","ux-ui"],title:"Thời đại của Pixel Perfect Design đã hết từ lâu - Phần 3",desc:"UI kit là tất cả những elment bạn đang sử dụng trong project, nếu là dân React có thể gọi là component. Sau này khi muốn maintenance sẽ dễ dàng hơn khi dự án ngày càng phình ra."}}},pathContext:{prev:{excerpt:"Mục Lục Chuyện gì xảy ra khi gọi   ? Sự khác nhau giữa Element và Component trong React? Khi nào thì sử dụng Class Component và Functional Component  trong React dùng để làm gì Keys trong React là gì Sự khác nhau giữa controlled component và...",html:'<p>Mục Lục</p>\n<!-- MarkdownTOC -->\n<ul>\n<li>Chuyện gì xảy ra khi gọi <code class="language-text">setSate</code> ?</li>\n<li>Sự khác nhau giữa Element và Component trong React?</li>\n<li>Khi nào thì sử dụng Class Component và Functional Component</li>\n<li><code class="language-text">Refs</code> trong React dùng để làm gì</li>\n<li>Keys trong React là gì</li>\n<li>\n<p>Sự khác nhau giữa controlled component và uncontrolled component</p>\n<ul>\n<li>Controlled Component</li>\n<li>Uncontrolled Component</li>\n</ul>\n</li>\n<li>Để gọi AJAX, sự dụng sự kiện nào của lifecycle?</li>\n<li><code class="language-text">shouldComponentUpdate</code> dùng để làm gì</li>\n<li>Build Product bằng cách nào?</li>\n<li>Tại sao nên sử dụng <code class="language-text">React.Children.map()</code> thay vì <code class="language-text">props.children.map()</code></li>\n<li>Events được xử lý trong React như thế nào?</li>\n<li>Sự khác nhau giữa <code class="language-text">createElement</code> và <code class="language-text">cloneElement</code></li>\n<li>Argument thứ 2 của <code class="language-text">setState</code> dùng để làm gì</li>\n<li>Đoạn code sau sai ở chổ nào</li>\n</ul>\n<!-- /MarkdownTOC -->\n<h2>Chuyện gì xảy ra khi gọi <code class="language-text">setSate</code> ?</h2>\n<p>Đầu tiên, object được truyền trong <code>setState</code> sẽ được merge với state hiện tại của component, dựa trên sự thay đổi của object này, UI được update với state mới. Để làm được chuyện này, React sẽ dựng một cây React Element mới, so sánh sự khác nhau của cây element mới và cây element trước đó, React biết được chính xác chỉ cần update phần UI nào đã bị thay đổi.</p>\n<h2>Sự khác nhau giữa Element và Component trong React?</h2>\n<p>React Element ám chỉ những gì thấy trên màn hình.</p>\n<p>React component là một function hoặc class có hoặc không có input và sẽ trả về một React element.</p>\n<h2>Khi nào thì sử dụng Class Component và Functional Component</h2>\n<p>Nếu component có state và các phương thức của lifecycle, sử dụng <strong>Class Component</strong>, ngược lại dùng <strong>functional component</strong></p>\n<h2><code class="language-text">Refs</code> trong React dùng để làm gì</h2>\n<p>Refs cho phép access trực tiếp đến DOM element hoặc một instance của component</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> this.input = input} /></code></pre>\n      </div>\n<h2>Keys trong React là gì</h2>\n<p>Keys giúp React theo dõi sự thay đổi của một item trong list</p>\n<div class="gatsby-highlight">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>todoItems<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>task<span class="token punctuation">,</span> uid<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>task<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>\n      </div>\n<h2>Sự khác nhau giữa controlled component và uncontrolled component</h2>\n<p>Controlled component là component React control dữ liệu dựa trên state và props, uncontrolled component là component mà dữ liệu được handle bởi DOM</p>\n<h4>Controlled Component</h4>\n<div class="gatsby-highlight">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">\'</span>text<span class="token punctuation">\'</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>username<span class="token punctuation">}</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>updateUsername<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></code></pre>\n      </div>\n<h4>Uncontrolled Component</h4>\n<div class="gatsby-highlight">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">\'</span>text<span class="token punctuation">\'</span></span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span>input <span class="token operator">=</span> input<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></code></pre>\n      </div>\n<h2>Để gọi AJAX, sự dụng sự kiện nào của lifecycle?</h2>\n<p><code class="language-text">componentDidMount</code> , lý do ko sử dụng <code>componentWillMount</code> vì React  có thể gọi componentWillMount nhiều lần nếu cần thiết, thứ 2 không thể chắc chắn AJAX luôn gọi thành công, nếu gơi vào trường hợp đó câu lệnh <code>setState</code> sẽ chạy trên unmounted component.</p>\n<h2><code class="language-text">shouldComponentUpdate</code> dùng để làm gì</h2>\n<p><code class="language-text">shouldComponentUpdate</code> cho phép can thiệp quá trình update UI của component và các component con của nó.</p>\n<h2>Build Product bằng cách nào?</h2>\n<p>Sử dụng phương thức DefinePlugin của Webpack để set <code class="language-text">NODE_ENV = production</code>. Quá trình build production sẽ bỏ hết những đoạn như validate propType, cảnh báo này nọ, minify code, remove comments.</p>\n<h2>Tại sao nên sử dụng <code class="language-text">React.Children.map()</code> thay vì <code class="language-text">props.children.map()</code></h2>\n<p><code class="language-text">props.children</code> chưa chắc lúc nào cũng là array. Ví dụ</p>\n<div class="gatsby-highlight">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Parent</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Welcome<span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Parent</span><span class="token punctuation">></span></span></code></pre>\n      </div>\n<p>Nếu sử dụng <code class="language-text">props.children.map</code> trong Parent sẽ bị lỗi vì <code class="language-text">props.children</code> là một object không phải array.</p>\n<div class="gatsby-highlight">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Parent</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Welcome<span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>props<span class="token punctuation">.</span>children will now be an array<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Parent</span><span class="token punctuation">></span></span></code></pre>\n      </div>\n<p><code class="language-text">React.Children.map</code> cho phép <code class="language-text">props.children</code> là array hoặc object đều được.</p>\n<h2>Events được xử lý trong React như thế nào?</h2>\n<p>Các hàm xử lý event trong React sẽ được truyền vào một instance của <code class="language-text">SyntheticEvent</code>, <code class="language-text">SyntheticEvent</code> cũng giống như những native event bình thường của Browser trừ việc nó có thể làm việc trên tất cả các trình duyệt.</p>\n<p>React không attach event vô các child node, mà sẽ lắng nghe tất cả các event sử dụng 1 event listener duy nhất, Với mục đích là để tăng performance và React không cần phải update lại event listener khi update DOM.</p>\n<h2>Sự khác nhau giữa <code class="language-text">createElement</code> và <code class="language-text">cloneElement</code></h2>\n<p><code class="language-text">createElement</code> là để tạo element, <code class="language-text">cloneElement</code> copy element và đưa vào các props mới.</p>\n<h2>Argument thứ 2 của <code class="language-text">setState</code> dùng để làm gì</h2>\n<p>callback function, function sẽ chạy sau khi <code class="language-text">component</code> được <code class="language-text">render</code> lại với state mới.</p>\n<p><code class="language-text">setState</code> là một phương thức bất đồng bộ (asynchronous)</p>\n<h2>Đoạn code sau sai ở chổ nào</h2>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">,</span> props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n <span class="token keyword">return</span> <span class="token punctuation">{</span> streak<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>streak <span class="token operator">+</span> props<span class="token punctuation">.</span>count <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>Không sai gì cả, ít người biết rằng khi <code class="language-text">setState</code> có thể truyền vào <code class="language-text">previous state</code>.</p>\n<p>Nguồn</p>\n<p><a href="https://tylermcginnis.com/react-interview-questions/">https://tylermcginnis.com/react-interview-questions/</a></p>',id:"E:/anluu/luckyluu/posts/2017-07-17-interview-react-developer-thi-hoi-gi/index.md absPath of file >>> MarkdownRemark",timeToRead:4,frontmatter:{date:"2017-07-17T13:35:13.234Z",path:"/2017-07-17-interview-react-developer-thi-hoi-gi",tags:["javascript","react"],title:"Interview React Developer thì hỏi gì?"}},next:{excerpt:"Grid Responsive design Đừng sáng tạo ra cái có sẵn Hiệu ứng Grid Khi bắt dầu dàn trang cho web, hãy sử dụng những hệ thống grid phổ biến hiện nay như  Bootstrap Grid . Nếu bạn là designer mà chưa biết đến CSS framework này thì thiệt thiếu xót trầm...",html:'<!-- MarkdownTOC -->\n<ul>\n<li>Grid</li>\n<li>Responsive design</li>\n<li>Đừng sáng tạo ra cái có sẵn</li>\n<li>Hiệu ứng</li>\n</ul>\n<!-- /MarkdownTOC -->\n<h1>Grid</h1>\n<p>Khi bắt dầu dàn trang cho web, hãy sử dụng những hệ thống grid phổ biến hiện nay như <a href="http://getbootstrap.com/css/#grid" target="_blank">Bootstrap Grid</a>. Nếu bạn là designer mà chưa biết đến CSS framework này thì thiệt thiếu xót trầm trọng, nó giải quyết phần lớn các yêu cầu cơ bản về layout, thống nhất sử dụng ngay từ đầu sẽ giúp ít rất nhiều cho mấy anh developer. Quan trọng nhất nên lưu ý là hệ thống grid ngày nay sử dụng độ rộng tương đối (theo giá trị phần trăm của container) và khoảng cách padding cố định. Bạn có thể đọc <a href="https://medium.com/sketch-app-sources/fluid-grid-systems-in-sketch-3-9-2579133c6d08" target="_blank">bài viết sau</a> để hiểu cách xây dựng hệ thống grid trên Sketch</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*WLHweZ4cQQSK8hWOY96cbQ@2x.png"></p>\n<p>Khi sử dụng hệ thống grid như bootstrap bạn sẽ không bao giờ cần phải nói cho anh developer kích thước của từng cột là mấy, vì thực sự lúc này kích thước nó chỉ là một giá trị tương đối</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*Q_qCy_5PPuR5bPciB5Vbeg@2x.png"></p>\n<h1>Responsive design</h1>\n<p>Bạn designer chỉ cần chỉ cho anh developer từng element nó sẽ như thế nào trên các kích thước màn hình khác nhau, luôn luôn nghĩ các element có một kích thước tương đối chứ không phải một giá trị cố định nào đó như 320 - 1024 -1920, vì giao diện responsive phải có khả năng thích nghi với nhiều dạng kích thước màn hình khác nhau nữa.</p>\n<p>Không chỉ vậy, một số hình có kích thước phụ thuộc vào container của nó, ví dụ trên desktop bạn cho một cái hình kích thước 200x200, nhưng trên điện thoại kích thước của màn hình sẽ là 375x667 đi, thì các hình này chắc chắn bể liền, thường thấy trên mấy cái thumbnail bài viết.</p>\n<p>Một lỗi thường thấy khác là quên rằng độ cao của một số element sẽ thay đổi theo <code class="language-text">container</code></p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*0odC4Yn4aHanIatRPU7P5w.gif"></p>\n<p>Sử dụng những <code class="language-text">breakpoint</code> căn bản: 320-375-768-1024-1280-1366-1920. Và tất nhiên tất cả các anh designer đều quên là giao diện đôi khi được xem trên màn hình lật ngang ra.</p>\n<p>Ví dụ bên dưới 2 cột hiển thị rất đẹp trên desktop nhưng do sự thay đổi độ cao trên mobile mà nó sẽ trở nên xấu xí</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*BWi61OpjqFEgHliraTHuLw@2x.png"></p>\n<h1>Đừng sáng tạo ra cái có sẵn</h1>\n<p>Nếu không có thời gian, hoặc không chắc có thể customize những component nhỏ xíu như cái dropdown theo kiểu "thích vẽ sau vẻ", hỏi anh developer xem anh có suggest cái thư viện nào có sẵn, thay vì làm lại cái người ta đã làm tốt lắm rồi. Một ví dụ kinh điển là cái datepicker. Rát nhiều designer nghĩ chỉ cần vẽ cái lịch với con số trên đó, mà quên rằng</p>\n<ul>\n<li>Hover effect trên từng ngày</li>\n<li>Trạng thái ngày hiện tại</li>\n<li>Làm sau đánh dấu ngày được chọn</li>\n<li>Làm sau thay đổi tháng, năm</li>\n<li>Ngày trước và sau của tháng hiện tại</li>\n</ul>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*Cgndb4fH9aXPnrLIuyuE4Q@2x.png"></p>\n<p>Chúng ta đang sống trong cái thời đại mà mọi người đều cố xây dựng mọi thứ của riêng mình (style nhật bổn). Đôi khi, có một sản phẩm chạy dược cho khách hàng thì tốt hơn là lãng phí thời gian và tiền bạc cho một anh designer ngồi đó sáng tạo ra những thứ người ta đã có sẵn. Designer phải biết rằng anh có thể sử dụng những thư viện và component có sẵn  để hoàn tất project. Nó sẽ giảm đi effect không chỉ của designer mà còn cả developer ngồi đó tìm ra những giải pháp không thực sự cần thiết</p>\n<h1>Hiệu ứng</h1>\n<p>Thay vì ngồi viết note giải thích các trang flow đi như thế nào, viết docs như vậy thực sự méo cần thiết. Designer chỉ cần sử dụng những trang như InVision hay Axure để biểu diễn cái flow,  dụng Principle, Framer, Adobe After Effect để mô tả mấy hiệu chạy thế nào. Nó sẽ giảm đi những hiểu nhầm giữa designer và developer, khách hàng</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*yEMXAwVff__nrM_OCwLknw.gif"></p>\n<p>Phần 3 - UI kits, Export, Element State, Line-height, Fonts</p>',id:"E:/anluu/luckyluu/posts/2017-03-07-thoi-dai-cua-pixel-perfect-da-het-phan-2/index.md absPath of file >>> MarkdownRemark",timeToRead:3,frontmatter:{date:"2017-03-07T13:35:13.234Z",path:"/2017-03-07-thoi-dai-cua-pixel-perfect-da-het-phan-2",tags:["css","ux-ui"],title:"Thời đại của Pixel Perfect Design đã hết từ lâu - Phần 2"}}}}}});
//# sourceMappingURL=path---2017-03-08-thoi-dai-cua-pixel-perfect-da-het-phan-3-06ce6beda5a66a0c14c3.js.map